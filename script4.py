# requires pandas
import pandas

# define file paths
input_file = "/Users/santiagochang/Desktop/JSB/WBcel235/output_filtered_polycistronic.tsv"
output_file = "/Users/santiagochang/Desktop/JSB/WBcel235/output_uORF.tsv"

# input: filtered data frame generated by script.py followed by script3.py
# output: filtered data frame with columns for count, start indices, end indices of type A, B, C uORFs
def find_uORF(data_frame):
    # initialize arrays to track values by row
    A = []
    A_starts = []
    A_ends = []
    B = []
    B_starts = []
    B_ends = []
    C = []
    C_starts = []
    C_ends = []
    # iterate through rows of data frame
    for row in data_frame.itertuples(index=False):
        # initialize empty values for row-specific variables
        numA = 0
        A_start = []
        A_end = []
        numB = 0
        B_start = []
        B_end = []
        numC = 0
        C_start = []
        C_end = []
        # get cDNA sequence, end index of 5' UTR, and length of CDS
        sequence = str(row.cdna).upper()
        end = int(row.cds_start_in_mRNA)
        length = int(row.cds_length)
        # iterate through nucleotides of cDNA sequence
        for i in range(end):
            # if 'ATG' exists in 5' UTR
            if sequence[i:i+3] == 'ATG':
                # iterate through triplets following 'ATG'
                for j in range(i, len(sequence), 3):
                    # if stop codon...
                    if sequence[j:j+3] == 'TAA' or sequence[j:j+3] == 'TAG' or sequence[j:j+3] == 'TGA':
                        # ...before CDS -> type A
                        if j < end:
                            numA += 1
                            A_start.append(i)
                            A_end.append(j+2)
                            break
                        # ...same as CDS -> type C
                        elif j == end+length-3:
                            numC += 1
                            C_start.append(i)
                            C_end.append(j+2)
                            break
                        # ...after CDS and out of frame of CDS -> type B
                        else:
                            numB += 1
                            B_start.append(i)
                            B_end.append(j+2)
                            break
                # if no stop codon corresponding to encountered 'ATG' in whole sequence -> type B
                else:
                    numB += 1
                    B_start.append(i)
                    B_end.append(len(sequence)-1)
        # add row-specific information to arrays
        A.append(numA)
        A_starts.append(A_start)
        A_ends.append(A_end)
        B.append(numB)
        B_starts.append(B_start)
        B_ends.append(B_end)
        C.append(numC)
        C_starts.append(C_start)
        C_ends.append(C_end)
    # append arrays as new columns in data frame
    data_frame['type_A'] = A
    data_frame['A_starts'] = A_starts
    data_frame['A_ends'] = A_ends
    data_frame['type_B'] = B
    data_frame['B_starts'] = B_starts
    data_frame['B_ends'] = B_ends
    data_frame['type_C'] = C
    data_frame['C_starts'] = C_starts
    data_frame['C_ends'] = C_ends
    # return data frame with appended columns
    return data_frame

# read in input file
input_df = pandas.read_csv(input_file, sep='\t', comment = '#', header = 0)
# determine and append uORF information
output_df = find_uORF(input_df)
# output to file
output_df.to_csv(output_file, sep = '\t', index = False)